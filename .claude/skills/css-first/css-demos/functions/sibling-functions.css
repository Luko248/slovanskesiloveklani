/**
 * sibling-index() & sibling-count() Functions
 *
 * MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/sibling-index
 * MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/sibling-count
 * Baseline: üü£ Experimental (Chrome behind flag)
 *
 * Task: Dynamically style elements based on their position among siblings
 * Why: Replaces repetitive :nth-child() rules and inline --i variables
 *      with a single declaration ‚Äî cleaner staggered animations, dynamic sizing
 */


/* ==========================================================================
   WHAT THEY RETURN

   sibling-index() ‚Üí <integer> starting at 1 (1st child = 1, 2nd = 2, ...)
   sibling-count() ‚Üí <integer> total siblings including self

   Both usable in calc(), clamp(), and any math function.
   ========================================================================== */


/* ==========================================================================
   1. STAGGERED ANIMATION ‚Äî the killer use case
   One rule replaces N nth-child selectors.
   ========================================================================== */

/* ‚ùå OLD ‚Äî repetitive nth-child rules */
/*
.item:nth-child(1) { animation-delay: 0.1s; }
.item:nth-child(2) { animation-delay: 0.2s; }
.item:nth-child(3) { animation-delay: 0.3s; }
... repeat for every item ...
*/

/* ‚úÖ NEW ‚Äî single declaration */
.stagger-in > * {
  animation: fade-slide-in 0.4s ease both;
  animation-delay: calc(sibling-index() * 60ms);
}

@keyframes fade-slide-in {
  from {
    opacity: 0;
    translate: 0 1rem;
  }
}


/* ==========================================================================
   2. REVERSE STAGGER ‚Äî last item animates first
   ========================================================================== */

.stagger-reverse > * {
  animation: fade-slide-in 0.4s ease both;
  animation-delay: calc((sibling-count() - sibling-index()) * 60ms);
}


/* ==========================================================================
   3. DYNAMIC COLOR ‚Äî rainbow across siblings
   Distribute hue evenly regardless of how many items exist.
   ========================================================================== */

.rainbow > * {
  background-color: oklch(
    0.7
    0.15
    calc(360deg / sibling-count() * sibling-index())
  );
}


/* ==========================================================================
   4. PROGRESSIVE SIZING ‚Äî items grow with position
   ========================================================================== */

.progressive-bars > * {
  inline-size: calc(sibling-index() / sibling-count() * 100%);
  block-size: 2rem;
  background: oklch(0.6 0.15 250);
  border-radius: 0.25rem;
}


/* ==========================================================================
   5. GRID STAGGER ‚Äî stagger both opacity and position
   ========================================================================== */

.grid-reveal {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(min(100%, 10rem), 1fr));
  gap: 1rem;
}

.grid-reveal > * {
  animation: grid-pop 0.3s ease both;
  animation-delay: calc(sibling-index() * 40ms);
}

@keyframes grid-pop {
  from {
    opacity: 0;
    scale: 0.9;
  }
}


/* ==========================================================================
   6. CIRCULAR LAYOUT ‚Äî replace manual --i variable
   Previously required nth-child or inline style for --i.
   ========================================================================== */

.circle-layout {
  --radius: 8rem;
  position: relative;
  display: grid;
  place-items: center;
  inline-size: calc(var(--radius) * 2 + 4rem);
  aspect-ratio: 1;
}

.circle-layout > * {
  position: absolute;
  --angle: calc(360deg / sibling-count() * sibling-index());
  translate:
    calc(cos(var(--angle)) * var(--radius))
    calc(sin(var(--angle)) * -1 * var(--radius));
}


/* ==========================================================================
   7. STACKED CARDS ‚Äî offset by position
   ========================================================================== */

.card-stack {
  position: relative;
}

.card-stack > * {
  position: absolute;
  inset: 0;
  translate:
    calc(sibling-index() * 4px)
    calc(sibling-index() * 4px);
  z-index: calc(sibling-count() - sibling-index());
}


/* ==========================================================================
   8. DYNAMIC OPACITY ‚Äî fade items toward edges
   ========================================================================== */

.fade-edges > * {
  --center: calc(sibling-count() / 2);
  --distance: abs(calc(sibling-index() - var(--center)));
  opacity: calc(1 - var(--distance) / var(--center));
}


/* ==========================================================================
   9. COMPARISON: OLD vs NEW

   ‚ùå Old pattern (nth-child or inline styles):
   <li style="--i: 0">...</li>
   <li style="--i: 1">...</li>
   li { animation-delay: calc(var(--i) * 100ms); }

   ‚úÖ New pattern (sibling-index):
   <li>...</li>
   <li>...</li>
   li { animation-delay: calc(sibling-index() * 100ms); }

   No inline styles. No nth-child rules. Works with any number of items.
   ========================================================================== */
